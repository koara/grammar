/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. koara.jj */
/*@egen*/options {                                                                      STATIC=false;  UNICODE_INPUT = true;               }
PARSER_BEGIN(Koara)
  package io.koara;
  import java.util.Arrays;
  public class Koara/*@bgen(jjtree)*/implements KoaraTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTKoaraState jjtree = new JJTKoaraState();

/*@egen*/      private boolean blockAhead() {	    if(getToken(1).kind == EOL) {	      Token t;	      int i = 2;	        do {	          do {	            t = getToken(i++);	          } while (t.kind == SPACE || t.kind == TAB);	        } while(t.kind == EOL);      	        return (t.kind != EOF);	      }	      return false;	  }	  private boolean nextAfterSpace(Integer... tokens) {	      int i = skip(1, SPACE, TAB);	      return Arrays.asList(tokens).contains(getToken(i).kind);	  }	  private int skip(int offset, Integer... tokens) {	      for(int i=offset;;i++) {	        Token t = getToken(i);	        if(t.kind == EOF || !Arrays.asList(tokens).contains(t.kind)) { return i; }	      }	  }	  private boolean textAhead() {	    int i = skip(1, SPACE, TAB);	    if(getToken(i).kind == EOL && getToken(i+1).kind != EOL && getToken(i+1).kind != EOF) {	       return true;	    }	    return false;	  }      }
PARSER_END(Koara)

TOKEN : {
    <IMAGE_LABEL : "image:" >
  | <ESCAPED_CHAR : "\\" ["*", "`", "\\", "-", ".", "=", ">", "[", "(", "<", "]", ")", "_"] >
  | <ASTERISK : "*">
  | <BACKTICK: "`">
  | <BACKSLASH: "\\">
  | <CHAR_SEQUENCE: (~["*", "`", "\\", "-",  "0" - "9", ".", "=", ">", "[", "(", "<", "]", ")", "_", " ", "\t", "\r", "\n"])+>
  | <DASH: "-">
  | <DIGITS : (["0"-"9"])+>
  | <DOT: ".">
  | <EOL : (" " | "\t")* ("\r"|"\n"|"\r\n")>
  | <EQ: "=">
  | <GT: ">">
  | <LBRACK: "[">
  | <LPAREN: "(">
  | <LT: "<">
  | <RBRACK: "]">
  | <RPAREN: ")">
  | <SPACE: " ">
  | <TAB: "\t">
  | <UNDERSCORE: "_">
}

ASTDocument Document()           : {/*@bgen(jjtree) Document */
  ASTDocument jjtn000 = new ASTDocument(JJTDOCUMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Document */
  try {
/*@egen*/
  (LOOKAHEAD(1) <EOL>)*  WhiteSpace() [ BlockElement() (LOOKAHEAD({blockAhead()}) (<EOL> WhiteSpace())+ BlockElement())* (<EOL>)* WhiteSpace() ] <EOF>/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  { return jjtn000; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void BlockElement() : {} {
  Paragraph()
}

void Paragraph()            : {/*@bgen(jjtree) Paragraph */
  ASTParagraph jjtn000 = new ASTParagraph(JJTPARAGRAPH);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) Paragraph */
  try {
/*@egen*/
  Inline() (LOOKAHEAD({textAhead()}) LineBreak() WhiteSpace() Inline())*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Inline() : {} {
  (
      Text()    | LooseChar()
  )+
}

void Text()       : {/*@bgen(jjtree) Text */
                     ASTText jjtn000 = new ASTText(JJTTEXT);
                     boolean jjtc000 = true;
                     jjtree.openNodeScope(jjtn000);
/*@egen*/Token t; StringBuffer s = new StringBuffer();} {/*@bgen(jjtree) Text */
  try {
/*@egen*/
  (LOOKAHEAD(1) (   		t = <BACKSLASH>								{ s.append(t.image);}
      | t = <CHAR_SEQUENCE> 						{ s.append(t.image);}      | t = <DASH> 									{ s.append(t.image);}      | t = <DIGITS> 								{ s.append(t.image);}      | t = <DOT>									{ s.append(t.image);}      | t = <EQ>									{ s.append(t.image);}      | t = <ESCAPED_CHAR> 							{ s.append(t.image.substring(1)); }      | t = <GT>									{ s.append(t.image);}      | t = <LPAREN>								{ s.append(t.image);}      | t = <LT>									{ s.append(t.image);}      | t = <RBRACK>								{ s.append(t.image);}      | t = <RPAREN>								{ s.append(t.image);}      | LOOKAHEAD({!nextAfterSpace(EOL, EOF)}) (				t = <SPACE> 						{ s.append(t.image); }		  	  | t = <TAB> 							{ s.append("    "); }	  )
    )  )+/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { jjtn000.jjtSetValue(s.toString()); }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}void LooseChar()       : {/*@bgen(jjtree) Text */
                          ASTText jjtn000 = new ASTText(JJTTEXT);
                          boolean jjtc000 = true;
                          jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;} {/*@bgen(jjtree) Text */
  try {
/*@egen*/  (      t = <ASTERISK>    | t = <BACKTICK>    | t = <LBRACK>    | t = <UNDERSCORE>  )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  { jjtn000.jjtSetValue(t.image); }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/ 	}void LineBreak()            : {/*@bgen(jjtree) LineBreak */
  ASTLineBreak jjtn000 = new ASTLineBreak(JJTLINEBREAK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} {/*@bgen(jjtree) LineBreak */
  try {
/*@egen*/  (<SPACE> | <TAB>)* <EOL>/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void WhiteSpace() : {} {  (LOOKAHEAD (1) (<SPACE> | <TAB>))*}